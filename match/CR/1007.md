# codeforces1007
>   赛时状况

| 类型 | 已完成 | 不会写 | 来不及          |
| ---- | ------ | ------ | --------------- |
| 题号 | A      | B      | C、D1、D2、E、F |

得分状况：643（+249）



## 完成区

### 题目

A. The Play Never Ends

time limit per test

1 second

memory limit per test

256 megabytes

Let's introduce a two-player game, table tennis, where a winner is always decided and draws are impossible.

Three players, Sosai, Fofo, and Hohai, want to spend the rest of their lives playing table tennis. They decided to play forever in the following way:

-   In each match, two players compete while the third spectates.

    

-   To ensure fairness, no player can play three times in a row. The player who plays twice in a row must sit out as a spectator in the next match, which will be played by the other two players. Otherwise, the winner and the spectator will play in the next match, while the loser will spectate.

Now, the players, fully immersed in this infinite loop of matches, have tasked you with solving the following problem:

Given an integer kk, determine whether the spectator of the first match can be the spectator in the kk-th match.

Input

Each test contains multiple test cases. The first line contains the number of test cases tt (1≤t≤10001≤t≤1000). The description of the test cases follows.

The only line of each test case contains one integer kk (1≤k≤1091≤k≤109).

Output

For each test case, print "YES" (without quotes) if the spectator of the first match can be the spectator of the kk-th match, and "NO" (without quotes) otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

Example

Input

```
4
1
2
333
1000000000
```

Output

```
YES
NO
NO
YES
```

Note

In the first test case, the spectator of the first match is already a spectator in the 11st match.

In the second test case, the spectator of the first match will play in the 22nd match regardless of the result of the first match.

#### 题意

三个人打乒乓球，两人打，一人看

任何人不能连续打三局，超过两局后去当观众，让观众参赛

问：一个人第1局是观众，问第k局是不是观众

#### 障碍点

有一个干扰点，说什么否则的话输家去当观众，赢家和观众打这样子还要判断一把后谁赢了谁输了，但是题目并没有告诉谁赢谁输，这就会让人误以为要分情况讨论，但其实不是这样的

这个人第一局是观众，第二局打的时候不管面对的是第一局的赢家还是输家，都已经是他的第二场比赛了，那么第三场绝对得当观众。那么第三局时这也是这个人的第二场比赛，他下一局得下场。依次类推可以破解障碍

### 代码

#### 自己的

```c
//观察得这个人当观众的比赛依次是1,4,7...,3n+1
#include<stdio.h>

int main(){
	int T;int n;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		if(n%3==1) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

#### 借鉴者

```c++
#include<bits/stdc++.h>
using namespace std;
void solve() {
    int k;
    cin >> k;
    if (k % 3 == 1) {
        cout << "Yes\n";
    } else {
        cout << "No\n";
    }
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0);//这一句看不懂
    int tt = 1;
    cin >> tt;
    while (tt--) {
        solve();
    }
}
```

### 总结

理解题目失误,如果早知道第二场是第一场那个人的第二局那么求解会更快

但是发现了这一点还是挺棒的



## 未完成区

### 题目

B. Perfecto

time limit per test

1.5 seconds

memory limit per test

256 megabytes



A permutation pp of length nn∗∗ is *perfect* if, for each index ii (1≤i≤n1≤i≤n), it satisfies the following:

-   The sum of the first ii elements p1+p2+…+pip1+p2+…+pi is **not** a perfect square††.

You would like things to be perfect. Given a positive integer nn, find a *perfect* permutation of length nn, or print −1−1 if none exists.

∗∗A permutation of length nn is an array consisting of nn distinct integers from 11 to nn in arbitrary order. For example, [2,3,1,5,4][2,3,1,5,4] is a permutation, but [1,2,2][1,2,2] is not a permutation (22 appears twice in the array), and [1,3,4][1,3,4] is also not a permutation (n=3n=3 but there is 44 in the array).

††A perfect square is an integer that is the square of an integer, e.g., 9=329=32 is a perfect square, but 88 and 1414 are not.

Input

Each test contains multiple test cases. The first line contains the number of test cases tt (1≤t≤1041≤t≤104). The description of the test cases follows.

The first and only line of each test case contains a single integer nn (1≤n≤5⋅1051≤n≤5⋅105).

It is guaranteed that the sum of nn over all test cases does not exceed 106106.

Output

For each test case:

-   If no solution exists, print a single integer −1−1.
-   Otherwise, print nn integers p1,p2,…,pnp1,p2,…,pn — the *perfect* permutation you find.

If there are multiple solutions, print any of them.

Example

Input

```
3
1
4
5
```

Output

```
-1
2 4 1 3
5 1 4 3 2
```

Note

In the first test case, there is only one permutation with length n=1n=1 that is p=[1]p=[1], which is not *perfect*:

-   p1=1=x2p1=1=x2 for x=1x=1.

In the second test case, one possible *perfect* permutation with length n=4n=4 is p=[2,4,1,3]p=[2,4,1,3]:

-   p1=2≠x2p1=2≠x2;
-   p1+p2=2+4=6≠x2p1+p2=2+4=6≠x2;
-   p1+p2+p3=2+4+1=7≠x2p1+p2+p3=2+4+1=7≠x2;
-   p1+p2+p3+p4=2+4+1+3=10≠x2p1+p2+p3+p4=2+4+1+3=10≠x2.

In the third test case, one possible *perfect* permutation with length n=5n=5 is p=[5,1,4,3,2]p=[5,1,4,3,2]:

-   p1=5≠x2p1=5≠x2;
-   p1+p2=5+1=6≠x2p1+p2=5+1=6≠x2;
-   p1+p2+p3=5+1+4=10≠x2p1+p2+p3=5+1+4=10≠x2;
-   p1+p2+p3+p4=5+1+4+3=13≠x2p1+p2+p3+p4=5+1+4+3=13≠x2;
-   p1+p2+p3+p4+p5=5+1+4+3+2=15≠x2p1+p2+p3+p4+p5=5+1+4+3+2=15≠x2.

#### 题意

给你一个n,找到一个全排列,如果这个全排列的前i个数之和都不是完全平方数,输出这个全排列.找不到输出-1

>   根本不知道哪种方法能不超时地解出来

### 代码

~~~c++
#include<bits/stdc++.h>
using namespace std;
void solve() {
    auto check = [&](int k) {
        int j = sqrtl((int64_t)k * (k + 1) / 2);
        return ((int64_t)j * j != (int64_t)k * (k + 1) / 2);
    };
    int n;
    cin >> n;
    if (!check(n)) {
        cout << "-1\n";
        return;
    }
    vector<int> ans(n + 1);
    for (int i = 1; i <= n; i++) {
        ans[i] = i;
    }
    int j = 0;
    for (int i = 1; i <= n; i++) {
        while ((int64_t)j * j < (int64_t)i * (i + 1) / 2) j++;
        if ((int64_t)j * j == (int64_t)i * (i + 1) / 2) {
            swap(ans[i], ans[i + 1]);
        }
        cout << ans[i] << " ";
    }
    cout << "\n";
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    int tt = 1;
    cin >> tt;
    while (tt--) {
        solve();
    }
}
~~~



