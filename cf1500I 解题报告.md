# cf1500***I*** 解题报告

## A

### 题意

>   给定一个序列,删除其中值为a~k~的元素就获得删掉的元素和值的分数,同时必须删掉a~k-1~和a~k+1~,不获得a~k-1~和a~k+1~的分,尽可能地多删,最多能得多少分

### 思路

DP,数据量不大,直接遍历1到10000,如果选了i就不要选i+1和i-1

设a~i~为在前i个元素里面删得的最大分数,那么得出方程
$$
a[i]=max(a[i-1],a[i-2]+num[i]*i)
$$

### 代码

```c++
	for(i=0;i<n;i++){
		cin>>k;
		a[k]+=k;
	}
	for(i=2;i<100001;i++){
		a[i]=max(a[i]+a[i-2],a[i-1]);
	}
	cout<<a[i-1]<<endl;
	return 0;
```



## B

### 题意

>   有个人怕猫
>
>   家在根节点,餐厅在叶子节点
>
>   从家出发,碰到连续n只猫就不吃那家餐厅了
>
>   问有多少餐厅可以吃

### 思路

>   用vector建立邻接表
>
>   dfs遍历树,如果不是叶子节点就往下遍历			同时记录猫的只数,连续的超过了直接返回0,到叶子节点还能忍就返回1



>   怎么判断叶子节点
>
>   传参的时候记录父节点,在往下dfs时加一次遍历,如果这个节点的邻接点含有非父节点,则判断不是叶子并跳出

~~注意是连续的猫数量~~

```c++
int dfs(int k,int from,int cnt){
	if(a[k]) cnt++;
	else cnt=0;
	if(cnt>m) return 0;
	int s=0;
	int leaf=1;
	for(int i=0;i<G[k].size();i++){
		if(G[k][i]!=from){
			leaf=0;
			break;
		}
	}
	if(leaf) return 1;
	for(int i=0;i<G[k].size();i++){
		if(G[k][i]!=from)	s+=dfs(G[k][i],k,cnt);
	}
	return s;
}
```



## C

### 题意

>   判断一个串中是否含有"AB"和"BA",可交换顺序,但不能接——~~"ABA"或"BAB"~~

### 思路

>   分开搜,搜到一个从下一个位置搜起,保证不重不漏

```c++
	string ab="AB",ba="BA";
	ffab=S.find(ab),ffba=S.find(ba);
	if(ffab==string::npos||ffba==string::npos){
		cout<<"NO"<<endl;
		return 0;
	}
	else if(S.find("BA",ffab+2)!=string::npos||S.find("AB",ffba+2)!=string::npos){
		cout<<"YES"<<endl;
	}
	else cout<<"NO"<<endl;		
	}
```



#### 易错点

不能简单地通过搜两子串的出现位置判断

错误代码

```c++
	string ab="AB",ba="BA";
	ffab=S.find(ab),ffba=S.find(ba);
	if(ffab==string::npos||ffba==string::npos){
		cout<<"NO"<<endl;
		return 0;
	}
	else if(abs(ffab-ffba)>2){
```

反例ABABAB



## D

### 题意

>   q次查询给定区间的数，使得返回的和最大
>
>   相当于给一段区间涂色，把大的数填进颜色更深的地方

### 思路

>   第一眼想到暴力，真的就模拟去一遍遍地刷色了，结果肯定TLE



>   后来才发现有差分数组这种东西，来简单复习一下

对一段区间的数同时进行增减相同的值时，只需要对对应的差分数组区间头增，区间尾后减

原理：差分数组是通过$a'[i]=a[i]-a[i-1]$得到的,还原的时候计算前缀和即可,那这样的话头增之后该区间进行前缀和还原后每个值都增加,且只增加一次,那么区间后面由于减过这个值,所以还原后不变

核心代码

```c++
	while(q--){
		cin>>x>>y;
		a[x]++;
		a[y+1]--;
	}
	for(int i=1;i<=n;i++) a[i]+=a[i-1];
	sort(a+1,a+n+1);
	unsigned long long sum=0;
	for(int i=1;i<=n;i++){
		sum+=1LL*a[i]*b[i];
	}
```

**注意**(一个失智的小问题)

1LL放在前面和放在后面是不一样的~~,由于放在后面吃了很多发WA还没看出来~~



## E

### 题意

>   找一个数字串，看能不能整除8

### 思路

8的三位数论暴力算

```c++
if(str.find('0')!=string::npos)
if(str.find('8')!=string::npos)
if((a*100+b*10+c)%8==0)
if((a*10+b)%8==0)
if(a%8==0)
```

动态规划还不会写



## F

### 题意

>   樵夫砍树,如果树被已经砍倒的树挡住,就砍不了,求最大砍倒数

### 思路

>   两头树先往两边倒,再看中间的,任意定一个方向为正方向,优先往这边倒,倒不了再看反方向,如果反方向砍倒的话影响不到下一棵树,那么这棵树也倒,这样就相当于把树的位置移到了倒的位置

### 代码

```c++
int res=2;
		for(i=2;i<n;i++){
			if(a[i]-h[i]>a[i-1]) res++;
			else if(a[i]+h[i]<a[i+1]) res++,a[i]+=h[i];
		}
```

~~**易错点**:一定要加n=1的特判~~*~~吃了三发WA~~*



## G

### 题意

>输入一些人的得分记录,输出第一个的最高分的人

### 思路

>   学习map
>
>   先求出最高分,然后再模拟得分情况,输出第一个最高分

### 易错点

>   并非最终的最高分就是整个过程的最高分,也许有人登过顶又下坡了

### 代码

```c++
	for(i=1;i<=n;i++){
		cin>>s[i]>>a[i];
		nam[s[i]]+=a[i];
	}
	for(i=1;i<=n;i++){
		mmax=max(mmax,nam[s[i]]);
	}
	for(i=1;i<=n;i++){
		sco[s[i]]+=a[i];
		if(nam[s[i]]==mmax&&sco[s[i]]>=mmax)
			cout<<s[i]<<endl;
```



## H

### 题意

>   在第i秒选一个数给它加2^i-1^,使数列不减至少要多少秒

### 思路

>   周一刚好教了highbit,直接从前往后,递减了就算出highbit的位数,如果还有递减减得更多的,那就取大者

>   癫子癫子,如果后面那个数递减减得更多,但是它的highbit又和前面的那个数对应的highbit一样怎么办,那不是就造出来递减了?
>
>   尔辈不能究等比 !

### 代码

```c++
for(i=1;i<=n;i++){
    if(mmax<=a[i]) mmax=a[i];
    else{ll t=highbit(mmax-a[i]);t=turnbit(t);
        ans=max(ans,t);
    }
}
```



## I

### 题意

>集合已经有1,现在给了a和b,集合里面的其他树可有已有的数推出来

$$
m~新~=m~原~*a+b
$$

### 思路

>   数学题，看了题解才懂，算出来，枚举判断n=a^k1^+b*k2有没有解,a=1时加个特判

### 代码

```c++
if(a==1){
			if((n-1)%b==0) printf("Yes\n");
			else printf("No\n");
			continue;
		}
		int flag=0;
		ll k=1; 
		while(k<=n){
			if((n-k)%b==0) {flag=1;printf("Yes\n");break;}
			k*=a;
		}
		if(!flag) printf("No\n");
```



## J

### 题意

>   Kefa的一群朋友之间的贫富差距不能超过n,同时要这些人的友谊值最大

### 思路

>   先将朋友们按工资排好序，然后取每一段工资差小于n的子序列，取最大值

### 易错点

>   不是算和自己的工资差距,虽然这样写样例能过

### 代码

```c++
struct fri{
	long long mon;
	long long val;
}fr[100005];

bool cmp(fri a,fri b){
	return a.mon<b.mon;
}
/*\\*/
	sort(fr,fr+n,cmp);
	sum[0]=fr[0].val;
	for(int i=1;i<n;i++){
		sum[i]=sum[i-1]+fr[i].val;
		while(fr[i].mon-fr[j].mon>=m){
			j++;
		}
		ans=max(ans,sum[i]-sum[j-1]);
	}
```



## K

### 题意

>   从左至右选择性喝药,保证血量非负求最大瓶数

### 思路

>   DP或者贪心或综合两者,因为数据量小用的贪心_优先队列
>
>    
>
>   对应思路就是喝到要死了就把之前和的扣血最多的要吐出来

### 代码

```c++
for(i=0;i<n;i++){
		cin>>k;
		s+=k;
		q.push(k);
		while(s<0){
			s-=q.top();
			q.pop();
		}
	}
```



## L

~~关于午睡睡不着却想出来这道题目并用手机手搓后AC这件事![492f8b046b14267711a9f6bb399bf8ff](D:\Typora\PIC\492f8b046b14267711a9f6bb399bf8ff.jpg)~~

### 题意

>   走n步回到原点,有多少种走法

### 思路

画成上图更好理解 ~~显然也更帅~~

从最后第n一步考虑起,n-1时肯定不能在O点,所以考虑n-2时

要么在O点,然后走出去再回来

要么在外面,在玩会儿(走到其他点)再回来

得到递推公式
$$
f(n)=3f(n-1)+2f(n-2)
$$
然后用矩阵快速幂计算

$$
\begin{bmatrix}
2 & 1\\
3 & 0
\end{bmatrix}
$$
套上学期的板子

```c
void multim(Mat a,Mat b){
    int i,j,k;
    Mat c;
    memset(c,0,sizeof(c));
    for(i=0;i<N;i++){
        for(j=0;j<N;j++){
            for(k=0;k<N;k++){
                c[i][j]+=a[i][k]*b[k][j]%MOD;
                c[i][j]%=MOD;
            }
        }
    }
    memcpy(a,c,sizeof(c));
}
 
void mpow(Mat a,int n){
    Mat ans={{1,0},{0,1}},k;
    memcpy(k,a,sizeof(k));
    while(n){
        if(n&1) multim(ans,k);
        multim(k,k);
        n>>=1;
    }
    memcpy(a,ans,sizeof(ans));  
}
 
long long get(int n){
    if(n==2) return 3;
    if(n==1) return 0;
    Mat a={{2,1},{3,0}};
    mpow(a,n-2);
    return (a[0][0]*3)%MOD;
}
```



## M

### 题意

>   图论题,计算循环部件的数量,注意右上角那个不是

![img](https://espresso.codeforces.com/30ce280e3909f07846282f15b65779aa9a176e80.png)

### 思路

>   那么就简单了,邻接表建图后,加一个vector分别处理每一个分支,所有点度数都必须是2,dfs即可

### 代码

```c++
void dfs(int v){
	vis[v]=true;
	par.push_back(v);
	for(int i=0;i<G[v].size();i++){
		if(!vis[G[v][i]]){
			dfs(G[v][i]);
		}
	}
}
/*\\*/
for(int i=1;i<=n;i++){
		if(!vis[i]){
			flag=1;
			par.clear();
			dfs(i);
			for(int j=0;j<par.size();j++){
				if(d[par[j]]!=2){
					flag=0;
					break;
				}
			}
			if(flag) ans++;
		}
	}
```



## N

### 题意

>   真人快打之队友有点菜
>
>   队友开始,轮流打BOSS
>
>   每人一次杀1或2只BOSS
>
>   队友只能打简单的,而你能打难的,队友要是不得不打难道就用跳过卡
>
>   求最少要用多少跳过卡

### 思路

>   注意到如果出现0的话不管连续几个,都有办法让队友多吃,然后两人一起处理(自己面对)接下来出现的1
>
>   1->0			11->0			111->1			1111->1
>
>   其实就是$num(1)/3$
>
>   特判第一个BOSS,若是1队友必须用跳过卡

### 代码

```c++
if(a[0]==1) ans=1;
for(int i=1;i<n;i++){
	if(!a[i]) continue;
	else{int j=i;
		while(a[j]==1&&j<n){
			j++;
		}
		
		ans+=(j-i)/3;i=j-1;
	}
}
```

***OVER!***

